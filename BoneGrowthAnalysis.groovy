/**
 * This groovy script is for analyzing bone growth within two masked regions of a single density calibrated microCT input image,
 * with one region (side) serving as the control, and the other the experimental region. 
 * 
 * Script code assumes straight line density calibration. `minImageBoneHA` variable is tuned for mgHA/ccm density calibration.
 * 
 * Masks were generated by hand using the Draw 3D ROI plugin, with the following parameters:
 * Front perspective (from above): 5 mm diameter circle
 * Both side perspectives: 2.5 mm thick rotated rectangle that extends in length beyond the edges of the circle
 * 
 * @param inputImage the original calibrated 3D CT input image 
 * @param controlMask A mask denoting the control side analysis region
 * @param experimentalMask A mask denoting the experimental side analysis region
 * 
 * @author Andrew McCall
 **/
 
float minImageBoneHA = 400.0;
RectangleShape shape = new RectangleShape(1, true);

import io.scif.config.SCIFIOConfig;

import ij.IJ;
import ij.ImagePlus;
import ij.measure.Calibration;

import net.imagej.axis.Axes;
import net.imagej.Dataset; 

import net.imglib2.algorithm.neighborhood.RectangleShape;
import net.imglib2.algorithm.labeling.ConnectedComponents.StructuringElement;
import net.imglib2.Cursor;
import net.imglib2.img.Img;
import net.imglib2.IterableInterval;
import net.imglib2.type.logic.*;
import net.imglib2.roi.mask.integer.RandomAccessibleIntervalAsMaskInterval;
import net.imglib2.roi.*;
import net.imglib2.roi.labeling.*;
import net.imglib2.type.numeric.ComplexType;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;
import net.imglib2.util.FlatCollections;

import org.scijava.plot.*;
import org.scijava.plot.defaultplot.*;
import org.scijava.table.Table;
import org.scijava.table.Tables;
import org.scijava.ui.swing.viewer.plot.jfreechart.CategoryChartConverter;

import org.jfree.chart.ChartUtils;
import org.jfree.chart.JFreeChart;

import java.io.File;

import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation

import com.google.common.collect.ImmutableMap;

//Importing as ImagePlus as this seems to be the only way to get the Density calibration
#@ ImagePlus inputImagePlus
#@ Dataset controlMask
#@ Dataset experimentalMask

#@ UIService uiService
#@ CommandService commandService
#@ DatasetService datasetService
#@ OpService ops
#@ DatasetIOService datasetioService
#@ IOService ioService
#@ ConvertService convertService
#@ PlotService plotService

Table concatenatedTable;

ArrayList<HashMap<String, Long>> runningTable = new ArrayList<>();
ArrayList<String> imageNames = new ArrayList<>();
 
LinkedHashMap<String, Object> getBoneMeasurements(Dataset inputImage, Dataset analysisRegionDS, Img<BitType> bone, Calibration cal){
	
	config = new SCIFIOConfig();
	config.writerSetFailIfOverwriting(false);
	config.put("WRITE_BIG_TIFF", true);
	outputDir = inputImage.getSource() + "-output" + File.separator;
	new File(outputDir).mkdirs();
	
	double voxelVolume = inputImage.axis(Axes.X).get().calibratedValue(1)*inputImage.axis(Axes.Y).get().calibratedValue(1)*inputImage.axis(Axes.Z).get().calibratedValue(1);
	
	Img<BitType> analysisRegion = ops.convert().bit(analysisRegionDS);
	
	LinkedHashMap<String, Object> returnValues = new LinkedHashMap();
	
	println("-Isolating bone in region");
	boneInAnalysis = analysisRegion.factory().create(analysisRegion);
	negInAnalysis =  analysisRegion.factory().create(analysisRegion);
	
	Cursor boneOutput = boneInAnalysis.cursor();
	Cursor noBoneOutput = negInAnalysis.cursor();
	Cursor regionCursor = analysisRegion.cursor();
	Cursor boneCursor = bone.cursor();
	
	while(boneOutput.hasNext()){
		boneOutput.fwd();
		noBoneOutput.fwd();
		regionCursor.fwd();
		boneCursor.fwd();
		if(regionCursor.get().get()){
			if(boneCursor.get().get()){
				boneOutput.get().set(true);
			}
			else{
				noBoneOutput.get().set(true);
			}
		}
	}
	
	
	//region BoneJ connectivity analysis
	boneInAnalysisImgPlus = ops.create().imgPlus(boneInAnalysis, analysisRegionDS);
	
	//uiService.show(boneInAnalysisImgPlus);
	
	Table boneJResults = commandService.run("org.bonej.wrapperPlugins.ConnectivityWrapper", false,
		"inputImage", boneInAnalysisImgPlus
	).get().getOutput("resultsTable");
	
	//endRegion
	
	
	//region EDT analysis
	
//	println("-Generating EDT");
//	//EDT image is not calibrated, output must be multiplied by Axis calibration
//	Img<FloatType> negativeEDT = ops.image().distancetransform(negInAnalysis);
//	
//	FloatType recal = new FloatType((float)inputImage.axis(Axes.X).get().calibratedValue(1));
//	negativeEDT = ops.math().multiply(negativeEDT, recal);
//	println("-Saving EDT");
//	datasetioService.save(datasetService.create(negativeEDT), outputDir + analysisRegionDS.getName() + "-edt.tif", config);
//	
//	println("-Analyzing EDT");
//	IterableInterval<FloatType> sampledNegEDT = Regions.sampleWithMask(new RandomAccessibleIntervalAsMaskInterval(analysisRegion), negativeEDT);
//	Collection<double> negativeEDTvalues = new ArrayList();
//	sampledNegEDT.cursor().forEachRemaining((pixel)->{
//		negativeEDTvalues.add(pixel.getRealDouble())
//	});
//	returnValues.put("NegEDTcollection", negativeEDTvalues);
	
	//endRegion
	
	bv = Regions.countTrue(boneInAnalysis)*voxelVolume;
	tv = Regions.countTrue(analysisRegion)*voxelVolume;
	
	//region Bone Analysis
	IterableInterval<FloatType> sampledBone = Regions.sampleWithMask(new RandomAccessibleIntervalAsMaskInterval(boneInAnalysis), inputImage);
	
	List<double> particleSize = new ArrayList();
	ImgLabeling labeledBones = ops.labeling().cca(boneInAnalysis, StructuringElement.EIGHT_CONNECTED);
	LabelRegions<BoolType> collectiveBones = new LabelRegions(labeledBones);

	println("-Counting bones");
	collectiveBones.forEach(individualBone -> {
		particleSize.add(individualBone.size()*voxelVolume);
	});

	StandardDeviation sdCalc = new StandardDeviation();
	sdCalc.setData(particleSize.toArray(new Double[0]));
	//endregion

	returnValues.put("Bone Volume", bv);
	returnValues.put("Total Volume", tv);
	returnValues.put("BV/TV", (bv/tv));
	//returnValues.put("Max bone gap radius", ops.stats().max(sampledNegEDT));
	returnValues.put("Number of bones", particleSize.size());
	returnValues.put("Mean bone volume (cubic mm)", particleSize.stream()
        .mapToDouble(a -> a)
        .average()
        .orElse(0.0)
    );
    returnValues.put("Bone size SD", sdCalc.evaluate());
	returnValues.put("Bone density mean (mgHA/ccm)", cal.getCValue(ops.stats().mean(sampledBone).getRealDouble()));
	returnValues.put("Bone density SD (mgHA/ccm)", cal.getCValue(ops.stats().stdDev(sampledBone).getRealDouble())-cal.getCoefficients()[0]);
	returnValues.put("Euler char.", boneJResults.get(0,0));
	returnValues.put("Corr. Euler", boneJResults.get(1,0));
	returnValues.put("Connectivity", boneJResults.get(2,0));
	returnValues.put("Conn.D(mm-3)", boneJResults.get(3,0));
	
	boneJResults.removeRow(0);
	//boneJResults.clear();
	
	return returnValues;
}

Calibration cal = inputImagePlus.getCalibration();


Dataset imageDS = convertService.convert(inputImagePlus, net.imagej.Dataset.class);

imageSource = imageDS.getSource();
outputDir = imageDS.getSource() + "-output" + File.separator;

ComplexType threshold = imageDS.getType();
threshold.setReal((int)Math.round(cal.getRawValue(minImageBoneHA)));

println("Segmenting bone");
Img<BitType> boneMask = ops.threshold().apply(imageDS, threshold);

println("Performing binary open");
boneMask = ops.morphology().erode(boneMask, shape);
boneMask = ops.morphology().dilate(boneMask, shape);

println("Analyzing control region");
imageNames.add(inputImagePlus.getShortTitle() + ": Control Region");
runningTable.add(getBoneMeasurements(imageDS, controlMask, boneMask, cal));
println("Analyzing experimental region");
imageNames.add(inputImagePlus.getShortTitle() + ": Experimental Region");
runningTable.add(getBoneMeasurements(imageDS, experimentalMask, boneMask, cal));

//region Saving box plot

//println("Creating box plot");
//CategoryChart boxPlot = plotService.newCategoryChart();
//
//boxPlot.addBoxSeries().setValues(ImmutableMap.of(
//		"Control region", runningTable.get(0).get("NegEDTcollection"),
//		"Experimental region", runningTable.get(1).get("NegEDTcollection")
//	));
//
//println("Saving box plot");
//File plotout = new File(outputDir + "BoxPlot.png");
//CategoryChartConverter converter = new CategoryChartConverter();
//ChartUtils.saveChartAsPNG(plotout, converter.convert(boxPlot, JFreeChart.class), boxPlot.getPreferredWidth() * 2, boxPlot.getPreferredHeight() * 2);

//endRegion

runningTable.get(0).remove("NegEDTcollection");
runningTable.get(1).remove("NegEDTcollection");

concatenatedTable = Tables.wrap(runningTable, imageNames);

println("Closing and re-opening image due to strange bug");
inputImagePlus.close();
IJ.openImage(imageSource).show();

uiService.show(concatenatedTable);
ioService.save(concatenatedTable, outputDir + "concatenatedTable.csv");
println("Finished");
